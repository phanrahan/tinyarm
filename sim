import os
import sys

import mem
from arch import Arch

__all__  = ['read32', 'write32']
__all__ += ['readreg', 'writereg']
__all__ += ['readcpsr', 'CPSR_Z', 'CPSR_N', 'CPSR_C', 'CPSR_V']
__all__ += ['load', 'reset', 'execute']

arch = Arch('arm.arch')

TRACE = 1

DATAMASK = 0xffffffff

ADDRMASK = 0xFFFF
MAXADDR	= ADDRMASK+1

mem.init(MAXADDR)

CPSR_N	= (1<<31)
CPSR_Z	= (1<<30)
CPSR_C	= (1<<29)
CPSR_V	= (1<<28)
cpsr = 0

reg = 16*[0]

def read32( addr ):
    if addr & 0x3:
        raise "Unaligned memory access"

    if addr >= 0x2000000:
        print 'reading from peripheral register', '%08x' % addr
        return 0

    else:
        if addr < 0 or addr >= MAXADDR:
            raise 'Segmentation Fault'
        else:
            return mem.read32(addr)

def write32( addr, word ):
    if addr & 0x3:
        raise "Unaligned memory access"

    if addr >= 0x2000000:
        print 'peripheral register %08x = %08x' % (addr, word)

    else:
        if addr < 0 or addr >= MAXADDR:
            raise 'Segmentation Fault'
        else:
            mem.write32(addr, word)
            print 'mem[%08x] = %08x' % (addr, word)


def readreg( r ):
    global reg
    assert r >= 0 and r < 16
    data=reg[r]
    return data

def writereg( r, data ):
    global reg
    assert r >= 0 and r < 16
    if r != 15:
        print 'reg[%d] = %08x' % (r, data)
    reg[r]=data


def do_zflag ( x ):
    global cpsr
    if x==0: cpsr|= CPSR_Z
    else:    cpsr&=~CPSR_Z

def do_nflag ( x ):
    global cpsr
    if x&0x80000000: cpsr|= CPSR_N
    else:            cpsr&=~CPSR_N

def do_cflag ( a, b, c ):
    global cpsr
    cpsr&=~CPSR_C
    #rc=(a&0x7FFFFFFF)+(b&0x7FFFFFFF)+c #carry in
    #rc = (rc>>31)+(a>>31)+(b>>31)  #carry out
    #if rc&2: cpsr|=CPSR_C

def do_vflag ( a, b, c ):
    # V = (M^result)&(N^result)&0x80
    global cpsr
    cpsr&=~CPSR_V
    #rc=(a&0x7FFFFFFF)+(b&0x7FFFFFFF)+c #carry in
    #rc>>=31 #carry in in lsbit
    #rd=(rc&1)+((a>>31)&1)+((b>>31)&1) #carry out
    #rd>>=1 #carry out in lsbit
    #rc=(rc^rd)&1 #if carry in != carry out then signed overflow
    #if rc: cpsr|=CPSR_V


def do_logicflags( s, c ):
    if s:
        do_nflag(c)
        do_zflag(c)
        printcc()

def do_arithflags( s, a, b, c ):
    if s:
        do_cflag(a, b, c)
        do_vflag(a, b, c)
        do_nflag(c)
        do_zflag(c)
        printcc()

def readcpsr():
    return cpsr

def printcc():
    print 'Z=%d' % (1 if cpsr & CPSR_Z else 0),
    print 'N=%d' % (1 if cpsr & CPSR_N else 0),
    print 'C=%d' % (1 if cpsr & CPSR_C else 0),
    print 'V=%d' % (1 if cpsr & CPSR_V else 0),
    print

def pred( op ):
    if op == 0: return cpsr&CPSR_Z #Q
    if op == 1: return not (cpsr&CPSR_Z)
    if op == 2: return cpsr&CPSR_C
    if op == 3: return not (cpsr&CPSR_C)
    if op == 4: return cpsr&CPSR_N
    if op == 5: return not (cpsr&CPSR_N)
    if op == 6: return cpsr&CPSR_V
    if op == 7: return not (cpsr&CPSR_V)

    if op == 8: return (cpsr&CPSR_C) and (not (cpsr&CPSR_Z))
    if op == 9: return (cpsr&CPSR_Z) or (not (cpsr&CPSR_C))

    if op == 0xa: 
        ra=False
        if (cpsr&CPSR_N) and (cpsr&CPSR_V): ra = True
        if (not (cpsr&CPSR_N)) and (not (cpsr&CPSR_V)): ra = True
        return ra

    if op == 0xb: 
        ra=False
        if (not (cpsr&CPSR_N)) and (cpsr&CPSR_V): ra = True
        if (not (cpsr&CPSR_V)) and (cpsr&CPSR_N): ra = True
        return ra

    if op == 0xc: 
        ra=False
        if   (cpsr&CPSR_N) and (cpsr&CPSR_V) : ra = True
        if (not (cpsr&CPSR_N)) and (not (cpsr&CPSR_V)): True
        if cpsr&CPSR_Z: ra=FALSE
        return ra

    if op == 0xd: 
        ra=False
        if (not (cpsr&CPSR_N)) and (cpsr&CPSR_V): ra = True
        if (not (cpsr&CPSR_V)) and (cpsr&CPSR_N): ra = True
        if cpsr&CPSR_Z: ra = True
        return ra

    return True

def rotate(i, r):
    r = 2*r
    return (i >> r) | ((i << (32-r)) & 0xffffffff)

def fetch():
    addr=readreg(15)
    machinecode=read32(addr-8)
    writereg(15,addr+4)
    return addr, machinecode

def decode(addr, code):
    inst = arch.match(code)
    args = inst.bind(code)
    if 'o' in args:
        args['o'] = addr - 4 + 4 * args['o']
    return inst, args

def execute ():
    addr, code = fetch()

    inst, args = decode(addr, code)
    print "%08x" % (addr-8), "%08x:" % code, inst.dis(args)

    cc = args['f']
    if pred( cc ):
        # alu
        type = code & 0x0c000000
        if type == 0x00000000:
            s = args['s']

            ra = args['a']

            rb = args['b']
            b = readreg(rb)

            # ra = rb op imm
            if code & 0x02000000:
                c = rotate(args['u'], args['i'])
            else:
                rc = args['c']
                c = readreg(rc)

            if inst.match('and'):
                a = b & c
                writereg(ra,a)
                do_logicflags(s, a)

            elif inst.match('eor'):
                a = b ^ c
                writereg(ra,a)
                do_logicflags(s, a)

            elif inst.match('sub'):
                a = b - c
                writereg(ra,a)
                do_arithflags(s, b, -c, 0 )

            elif inst.match('rsb'):
                a = c - b
                writereg(ra,a)
                do_arithflags(s, c, -b, 0 )

            elif inst.match('add'):
                a = b + c
                writereg(ra,a)
                do_arithflags(s, b, c, 0 )

            elif inst.match('adc'):
                # b + c + carry
                a = b + c
                writereg(ra,a)
                do_arithflags(s, b, c, 0 )
                #if(cpsr&CPSR_C) rc++;
                #write_register(rd,rc);
                #do_nflag(rc);
                #do_zflag(rc);
                #if(cpsr&CPSR_C) { do_cflag(ra,rb,1); do_vflag(ra,rb,1); }
                #else            { do_cflag(ra,rb,0); do_vflag(ra,rb,0); }

            elif inst.match('sbc'):
                # b - c - 1 + carry
                a = b - c
                writereg(ra,a)
                do_arithflags(s, b, -c, 0 )
                #if(!(cpsr&CPSR_C)) rc--;
                #write_register(rd,rc);
                #do_nflag(rc);
                #do_zflag(rc);
                #if(cpsr&CPSR_C)
                #{
                #    do_cflag(ra,~rb,1);
                #    do_vflag(ra,~rb,1);
                #}
                #else
                #{
                #    do_cflag(ra,~rb,0);
                #    do_vflag(ra,~rb,0);
                #}

            elif inst.match('rsc'):
                # c - b - 1 + carry
                a = c - b
                writereg(ra,a)
                do_arithflags(s, c, -b, 0 )

            elif inst.match('tst'):
                a = b & c 
                do_logicflags(s, a)

            elif inst.match('teq'):
                a = b ^ c
                do_logicflags(s, a)

            elif inst.match('cmp'):
                a = b - c
                do_arithflags(s, b, -c, a)

            elif inst.match('cmn'):
                a = b + c
                do_arithflags(s, b, c, a)

            elif inst.match('orr'):
                a = b | c
                writereg(ra, a)
                do_logicflags(s, a)

            elif inst.match('mov'):
                a = c
                writereg(ra, a)
                do_logicflags(s, a)

            elif inst.match('bic'):
                a = b & ~c
                writereg(ra, a)
                do_logicflags(s, a)

            elif inst.match('mvn'):
                a = 0xffffffff ^ c
                writereg(ra, a)
                do_logicflags(s, a)

            else:
                 raise "Uniplemented Instruction"

        # LDR/STR
        elif type == 0x04000000:
            ra = args['a']

            rb = args['b']
            b = readreg(rb)

            c = args['u']

            # options
            #   t: 0 => no write back, 1 => write back
            #   r: 0 => word, 1 => byte
            #   q: 0 => down, 1 => up (down: subtract unsigned offset)
            #   p: 0 => post, 1 => pre 
            #        (perform offset before (pre) or after (post)
            #        if post-indexed is used, t must be 0
            #   understand how bytes are read
            #   understand alignment restrictions on word addresses
            #
            # [Rn] offset of 0
            # [Rn, #o]{!} pre-indexed, "!" causes write-back
            # [Rn, +/-Rm{,shift]]{!}
            #
            # [Rn], #o post-indexed, always write-back, W must be 0
            # [Rn], +/-Rm{,shift}

            if inst.match('str%'):
                a = readreg(ra)
                write32(b+c,a)

            elif inst.match('ldr%'):
                a = read32(b+c)
                writereg(ra,a)

            else:
                 raise "Uniplemented Instruction"


        elif type == 0x08000000:
            # branch
            if (code & 0x0e000000) == 0x08000000:
                #HALT = b .
                if code == 0xeafffffe:
                    global halt
                    halt = 1
                    print 'HALT'

                o = args['o']

                # the pc must be adjusted to point immediately following the bl
                if code & 0x01000000: # bl
                    writereg(14,reg[15]-8)
                writereg(15,o+8)

            # block data transfer
            else:
                 raise "Uniplemented Instruction"

        else:
             raise "Uniplemented Instruction"


def step():
    execute()

def cont():
    global halt
    halt = 0
    while not halt:
        execute()

def info():
    for r in range(16):
        if   r == 15:
            print 'pc  = %08x' % (reg[r]-8)
        elif r == 14:
            print 'lr  = %08x' % reg[r]
        elif r == 13:
            print 'sp  = %08x' % reg[r]
        elif r >= 10:
            print 'r%d = %08x' % (r, reg[r])
        else:
            print 'r%d  = %08x' % (r, reg[r])
    printcc()

def list():
    pc = readreg(15)
    for addr in range(pc,pc+64,4):
        code = read32(addr-8)
        inst = arch.match(code)
        args = inst.bind(code)
        if 'o' in args:
            args['o'] = addr + 4 * args['o']
        print "%08x" % (addr-8), "%08x:" % code, inst.dis(args)

def load(filename):
    mem.read(filename)
    reset()

def reset():
    global cpsr, reg
    cpsr = 0
    for i in range(15):
        reg[0] = 0

    reg[15] = 8

